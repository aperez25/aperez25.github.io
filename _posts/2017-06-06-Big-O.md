---
published: false
---
## O-M-G

When learning about Big O, you'll see phrases like "time or space complexity," which can be simplifeied to "How much time or space does the algorithm [i.e. function] takes as the input gets 'bigger?'"

What does bigger mean?
Well this might mean that the argument for our function gets larger - our array grows from 10 to 10000, we have a higher magnitude number, the number of distinct elements goes up. 

"Order of magnitude" - broad categorical level 
Indepenet of any specific machine - this is entirely theoretical - we don't care what kind of computer you're using. What is the shape of the growth curve? 

Technically: Big O is an upper bound - for large enough inputs. but: we usually use it like a tight bound - which at an academic level is called Big Theta. Tight bound - 

so something like 
function logElements (arr) {
	arr.forEach(element =>
    console.log element) 
    })
}

### what do we mean by upper bound? 
would be evaluated step-by-step: 
```js
function logElements (arr) {
	arr.forEach(element => O(n)
    console.log element) => O(1)
    })
}
```

we add those together: O(n + 1) -> for really large inputs, the constant will drop because the one doesn't really make a difference to its run time - so we get O(n)

O(n) gives us accuracy, "it's definitely not worse than...", so O(n^2), )(O(n log n)), O(2^n) - this is inclusive of all the other run times above it - but we care more about the runtime closest to the tight bound. So computer scientists are usally talking about Big Theta. 

So why do we say Big O? Well..Big O is easier to say & most don't care i.e. there's no good reason. 

If we actually run it (benchmarking) we can discover the concrete cost, but that is hard and annoying to determine beforehand. Everything in here is cheaper than I label it - but how much cheaper? 
Example: logElements costs O(n)
metaphorically: logElemets is cheaper than $20 
IT IS EQUALLY VALID (but not as useful) to say logElements is cheaper than $5000. Another way of saying this: logElememnts is not worse than factorial growth. (It's true, but not nearly as useful as knowing that it's not worse than linear) 

### what about average vs worst case? 

related, but confusingly related concept: Average vs. Worst Case
- Some types of inputs can cause the algorithm to have a different curve. 
```js
function containsZero(arr) {
	return arr.some(el => el === 0)
}
```
If you're not familiar with the .some method, under the hood it looks something like this, where predicate is the function to be used 

```js
Array.prototype.some = function(predicate) {
	for (let i = 0; i < this.length; i++) {
    	if predicate(this[i]) return true; 
    }
    return false; 
}
```
Usually the most important question is worse case:
-> worse case: going through whole array - O(n) 

Second most commonly cared about question is average
-> average case: going halfway through array still O(n)

Rarely care about best case, but sometimes it's good to know: 
-> best case: what wwe're looking for is the first element - O(1) 

If we're okay with the worst case, than we're definitely okay with the average cast and with the best case. 

Examples of when this matters: 
Hash tables! 
average time lookup for a value is O(1)
- hash the key
- go to that bucket 
- return the only value in the bucket 
**does't depend on hash table size **
worse case lookup is O(n)
- hash the key
- go to that bucket 
-search through linked list that gets bigger as more values are put into the hash table (n)
return the found value
**DOES depend on hash table size **

Instead of average, think "typical" - In a typical hash table, the hash table bucket has just one value - so even if you put in more data, it's constant. but at some criticial tipping point, the buckets become saturated and you lookup times start slowing down.

### what is NOT Big O?
it's not a tight bound (that's Big Theta)
It's not necessarily the best/average/woest case, but assume worst case (not always - think of hash table search) 
Not useful when the input is small, because the algorithm is fast anyway
NOT ACTUALLY TIME OR SPACE 
-huh? As in, not a concrete measurement like "2 seconds" or "5 bytes"
- it's a curve to which you can attach arbitraty units 
- divorced from actual execution ofo the algorithm on a real computer 
- hypothetical computer (RAM model of computing) 
describes solutions
has no real units unto itself 
the input (n, n + m, j, etc.) is defined per-problem

if someone says an algorithm is O(n), you may wonder, what is n? 
depends on the specific problem, might not be stated explicitly, the speaker assumes you are smart enough tot figure it out from context 

Example: `containsZero`, `n` is `arr.length`
second example: 
```js

function repeatHello(times) {
	for (var i =0, i < times, i++) console.log('Hello')
}

```
O(n) here refers to times - the for loop will depend on the size of this number which is O(n) 

** stating big O in an interview doesn't hurt anyone, and might actually help you - this is a linear algorithm based on the length of the array" that is a safe statement even if it is verbose 

###Common Big O notations: best to worst 
O(1) - constant
O(log(n)) - logarithmic 
O(n) - linear
O(n * log(n)) loglinear
O(n^2) - quadratic 
O(2^n) exponential 
O(n!) factorial 

Remember - jsut beecause it's constant, doesn't mean it's fast 
Big O is just one way to compare algorithms - sometimes a worse Big O is a better algorithm for certain reasons 
Example: V8 Quicksort is a hybrid algorithm 
* small (`<10 elements): uses insertion sort, )(n^2) average/worst`)
* big ( >10): quicksort, O(n log n) average case
why? when it's less than 10 elements, the actual run time for quick sort, it ends up being slower than insertion sort. 

### general procedure for determining Big O 
- disclaimer: it is a mathematial truth there is no such procedure - loose approach, but not a foolproof system

- Count the steps
	- Nesting: anytime you hit a loop, multiply number of iterations * max complexity of internals (what's inside the block) 
    - Siblings: take the biggest one, forget the rest 
- drop constants
-drop lower-order(smaller exponent) terms
- RAM model: 
	- simple operations are constant: assignment/declaration, operators (boolean, arithmetic), control flow(if / else, ternary, etc.), side effects(logging, input, etc) - SOMETIMES, return statements 
    - loops: see above
    - function calls: need to know their Big O or analyze function body 
O(a) + O(b) = O(a + b) 
O(a) * O(b) = O( a * b)
   
-O(a) denotes on average runtime 
```js
// O(?) n = arr.length 
 function shuffle(arr) { // summation of internal statements = > O(1) + O(1) + -O(n) +O(1) => -O(n)
 	var last, rand, temp, // O(1)
    i = arr.length; // O(1) + O(1) --> O(1 + 1) -> O(2) -> O(2 *1) -> 0(1)
    while (i--) { //  number of iterations [arr.length: O(n) ] * complexity of internals (O(1)) = O(n) 
    	last = arr[i] // O(1) + O(1) 
        rand = Math.floor(Math.random() * i) // O(1) + O(1)  + O(1) + O(1) = O(1)// if a function don't have an input, it must be O(1) since there isn't anything that can change its runtime, and for Math.floor, what kinds of numbers would make it really slow? that would be weird, so we can assume it's also constant time 
        temp = arr[i] //O(1)
        arr[i] = arr[rand] //O(1)
        arr[rand] = temp //this is a write into the array, but since array is a hash table, writing into is constant time - O(1) 
    }
    return arr; 
 }

```

*** COPY Gabe's example on space complexity 
cumulative assignments: if you keep re-assigning, still same amount of space, but new assigments take up space 
a function that takes constant space is also known as an "in place" algorithm - it's moving stuff around in the array 


space complexity: how much ADDITIONAL space will something take? 
have to understand how arrays are implemented in JS to do the Big O well, arrays are hash tables and their lookup is constant - avg case is therefore constant. in worst case, this might not be true, but usually this lookup is constant. 

Enter text in [Markdown](http://daringfireball.net/projects/markdown/). Use the toolbar above, or click the **?** button for formatting help.
